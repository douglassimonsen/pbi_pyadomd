{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Pbi_pyadomd is a fork of the original pyadomd library, designed to provide a typed Python interface for communicating with SQL Server Analysis Services (SSAS) instances. This library allows developers to execute DAX and XML queries against SSAS in a more structured and type-safe manner.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>python -m pip install pbi_pyadomd\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>Reading Data from an SSAS Table</p> <p>Note: in this version of pyadomd, executing a DAX returns a reader object rather than a cursor object. This is intended to provide a more consistent interface with the underlying C# Adomd library.</p> <pre><code>from pbi_pyadomd import Connection\n\nconn_str = \"Provider=MSOLAP;Data Source=localhost:51358;Initial Catalog=&lt;db_UUID&gt;;\"\nwith Connection(conn_str) as conn:\n    reader = conn.execute_dax(\"EVALUATE &lt;table_name&gt;\")\n    for row in reader.fetch_many():\n        print(row)\n</code></pre> <p>Streaming Results</p> <p>Note: when reading a query without a definite end, such as a SSAS Trace subscription, you can use the <code>fetch_stream</code> method to continuously read results as they become available. If you use the standard <code>fetch_many</code> method, it will block until the query completes, which may not occur.</p> <p>Both the Reader and Connection with statements automatically close their underlying resources when they go out of scope, so you do not need to explicitly close them.</p> <pre><code>from pbi_pyadomd import Connection\n\nconn_str = \"Provider=MSOLAP;Data Source=localhost:51358;Initial Catalog=&lt;db_UUID&gt;;\"\nxml_command = \"\"\"\n&lt;Subscribe xmlns=\"http://schemas.microsoft.com/analysisservices/2003/engine\"&gt;\n&lt;Object&gt;\n    &lt;TraceID&gt;{{trace_name}}&lt;/TraceID&gt;\n&lt;/Object&gt;\n&lt;SubscriptionId xmlns=\"http://schemas.microsoft.com/analysisservices/2018/engine/800\"&gt;{{subscription_name}}&lt;/SubscriptionId&gt;\n&lt;/Subscribe&gt;\n\"\"\"\nwith Connection(conn_str) as conn:\n    with conn.execute_xml(xml_command) as reader:\n        for row in reader.fetch_stream():\n            print(row)\n\n            # this break clause is a non-functional example to illustrate how you might stop reading\n            if row.val == \"EndOfStream\":\n                break\n</code></pre> <p>Executing Non Queries</p> <p>There are certain operations that do not return a result set, such as creating or altering database objects. You can execute these using the <code>execute_non_query</code> method.</p> <pre><code>from pbi_pyadomd import Connection\n\nconn_str = \"Provider=MSOLAP;Data Source=localhost:51358;Initial Catalog=&lt;db_UUID&gt;;\"\nwith Connection(conn_str) as conn:\n    result = conn.execute_non_query(\"CREATE TABLE &lt;table_name&gt; (id INT, name NVARCHAR(100))\")\n    print(result)  # prints \"None\"\n</code></pre>"},{"location":"api/Connection/","title":"Connection","text":"Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\conn.py</code> <pre><code>class Connection:\n    conn: AdomdConnection\n    \"\"\"The underlying C# AdomdConnection object.\"\"\"\n    reader: Reader\n    \"\"\"The python reader for the connection, used to execute queries.\"\"\"\n\n    def __init__(self, conn_str: str) -&gt; None:\n        self.conn = AdomdConnection(conn_str)\n\n    def clone(self) -&gt; \"Connection\":\n        \"\"\"Clones the connection.\"\"\"\n        return Connection(self.conn.ConnectionString)\n\n    def close(self) -&gt; None:\n        \"\"\"Closes the connection.\"\"\"\n        self.conn.Close()\n        self.conn.Dispose()\n\n    def open(self) -&gt; Self:\n        \"\"\"Opens the connection.\"\"\"\n        self.conn.Open()\n        return self\n\n    @property\n    def state(self) -&gt; ConnectionState:\n        \"\"\"1 = Open, 0 = Closed.\"\"\"\n        return ConnectionState(self.conn.State.value__)\n\n    def __enter__(self) -&gt; Self:\n        if self.state != ConnectionState.Open:\n            self.open()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: \"TracebackType | None\",  # noqa: PYI036\n    ) -&gt; None:\n        self.close()\n\n    def execute_xml(\n        self,\n        query: str,\n        query_name: str | None = None,\n    ) -&gt; bs4.BeautifulSoup:\n        query_name = query_name or \"\"\n        logger.debug(\"execute XML query\", query_name=query_name)\n        cmd = AdomdCommand(query, self.conn)\n\n        with Reader(cmd.ExecuteXmlReader()) as reader:\n            logger.debug(\"reading query\", query_name=query_name)\n            lines = [reader.read_outer_xml()]\n            while lines[-1] != \"\":\n                lines.append(reader.read_outer_xml())\n            ret = bs4.BeautifulSoup(\"\".join(lines), \"xml\")\n            for node in ret.find_all():\n                assert isinstance(node, bs4.element.Tag)\n                node.name = utils._decode_name(node.name)\n\n        return ret\n\n    def execute_non_query(self, query: str, query_name: str | None = None) -&gt; Self:\n        \"\"\"Executes a non-query DAX command.\n\n        Returns:\n            Self: The connection object itself for method chaining.\n\n        \"\"\"\n        query_name = query_name or \"\"\n        logger.debug(\"execute DAX query\", query_name=query_name)\n        cmd = AdomdCommand(query, self.conn)\n        cmd.ExecuteNonQuery()\n        return self\n\n    def execute_dax(self, query: str, query_name: str | None = None) -&gt; Reader:\n        \"\"\"Executes a DAX query and returns a Reader object.\n\n        Args:\n            query (str): The DAX query to execute.\n            query_name (str | None): Optional name for the query, used for logging.\n\n        Returns:\n            Reader: A Reader object to read the results of the query.\n\n        \"\"\"\n        query_name = query_name or \"\"\n        logger.debug(\"execute DAX query\", query_name=query_name)\n        cmd = AdomdCommand(query, self.conn)\n        return Reader(cmd.ExecuteReader())\n</code></pre>"},{"location":"api/Connection/#pbi_pyadomd.Connection.conn","title":"conn  <code>instance-attribute</code>","text":"<pre><code>conn: AdomdConnection = AdomdConnection(conn_str)\n</code></pre> <p>The underlying C# AdomdConnection object.</p>"},{"location":"api/Connection/#pbi_pyadomd.Connection.reader","title":"reader  <code>instance-attribute</code>","text":"<pre><code>reader: Reader\n</code></pre> <p>The python reader for the connection, used to execute queries.</p>"},{"location":"api/Connection/#pbi_pyadomd.Connection.state","title":"state  <code>property</code>","text":"<pre><code>state: ConnectionState\n</code></pre> <p>1 = Open, 0 = Closed.</p>"},{"location":"api/Connection/#pbi_pyadomd.Connection.clone","title":"clone","text":"<pre><code>clone() -&gt; Connection\n</code></pre> <p>Clones the connection.</p> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\conn.py</code> <pre><code>def clone(self) -&gt; \"Connection\":\n    \"\"\"Clones the connection.\"\"\"\n    return Connection(self.conn.ConnectionString)\n</code></pre>"},{"location":"api/Connection/#pbi_pyadomd.Connection.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Closes the connection.</p> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\conn.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the connection.\"\"\"\n    self.conn.Close()\n    self.conn.Dispose()\n</code></pre>"},{"location":"api/Connection/#pbi_pyadomd.Connection.execute_dax","title":"execute_dax","text":"<pre><code>execute_dax(\n    query: str, query_name: str | None = None\n) -&gt; Reader\n</code></pre> <p>Executes a DAX query and returns a Reader object.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The DAX query to execute.</p> required <code>query_name</code> <code>str | None</code> <p>Optional name for the query, used for logging.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Reader</code> <code>Reader</code> <p>A Reader object to read the results of the query.</p> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\conn.py</code> <pre><code>def execute_dax(self, query: str, query_name: str | None = None) -&gt; Reader:\n    \"\"\"Executes a DAX query and returns a Reader object.\n\n    Args:\n        query (str): The DAX query to execute.\n        query_name (str | None): Optional name for the query, used for logging.\n\n    Returns:\n        Reader: A Reader object to read the results of the query.\n\n    \"\"\"\n    query_name = query_name or \"\"\n    logger.debug(\"execute DAX query\", query_name=query_name)\n    cmd = AdomdCommand(query, self.conn)\n    return Reader(cmd.ExecuteReader())\n</code></pre>"},{"location":"api/Connection/#pbi_pyadomd.Connection.execute_non_query","title":"execute_non_query","text":"<pre><code>execute_non_query(\n    query: str, query_name: str | None = None\n) -&gt; Self\n</code></pre> <p>Executes a non-query DAX command.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The connection object itself for method chaining.</p> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\conn.py</code> <pre><code>def execute_non_query(self, query: str, query_name: str | None = None) -&gt; Self:\n    \"\"\"Executes a non-query DAX command.\n\n    Returns:\n        Self: The connection object itself for method chaining.\n\n    \"\"\"\n    query_name = query_name or \"\"\n    logger.debug(\"execute DAX query\", query_name=query_name)\n    cmd = AdomdCommand(query, self.conn)\n    cmd.ExecuteNonQuery()\n    return self\n</code></pre>"},{"location":"api/Connection/#pbi_pyadomd.Connection.open","title":"open","text":"<pre><code>open() -&gt; Self\n</code></pre> <p>Opens the connection.</p> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\conn.py</code> <pre><code>def open(self) -&gt; Self:\n    \"\"\"Opens the connection.\"\"\"\n    self.conn.Open()\n    return self\n</code></pre>"},{"location":"api/Reader/","title":"Reader","text":"Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\reader.py</code> <pre><code>class Reader:\n    _reader: \"IDataReader\"\n\n    def __init__(self, reader: \"IDataReader\") -&gt; None:\n        self._reader = reader\n\n    def __enter__(self) -&gt; \"Reader\":\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: \"TracebackType | None\",  # noqa: PYI036\n    ) -&gt; None:\n        self.close()\n\n    def close(self) -&gt; None:\n        self._reader.Close()\n\n    def column_names(self) -&gt; list[str]:\n        \"\"\"Returns the column names of the last executed query.\"\"\"\n        return [self._reader.GetName(i) for i in range(self.field_count)]\n\n    def descriptions(self) -&gt; list[Description]:\n        return [\n            Description(\n                self._reader.GetName(i),\n                adomd_type_map[self._reader.GetFieldType(i).ToString()].type_name,\n            )\n            for i in range(self.field_count)\n        ]\n\n    def fetch_one(self) -&gt; dict[str, Any]:\n        \"\"\"Fetches a single row from the last executed query as a dictionary.\n\n        Returns\n        -------\n            dict[str, Any]: A dictionary representing the row, with column names as keys\n\n        \"\"\"\n        column_names = self.column_names()\n        data = self.fetch_one_tuple()\n        return dict(zip(column_names, data, strict=False))\n\n    def fetch_one_tuple(self) -&gt; tuple[Any, ...]:\n        \"\"\"Fetches a single row from the last executed query as a tuple.\n\n        Returns:\n            tuple[Any, ...]: A tuple representing the row, with C# values converted\n                to their appropriate python types.\n\n        \"\"\"\n        return tuple(\n            convert(\n                self._reader.GetFieldType(i).ToString(),\n                self._reader[i],\n                adomd_type_map,\n            )\n            for i in range(self.field_count)\n        )\n\n    def fetch_many(self, limit: int | None = None) -&gt; list[dict[str, Any]]:\n        \"\"\"Fetches multiple rows from the last executed query.\n\n        Args:\n            limit (int | None): The number of rows to fetch. If None, fetches all rows.\n\n        Returns:\n            list[dict[str, Any]]: A list of dictionaries representing the rows.\n\n        \"\"\"\n        if limit is not None:\n            return [self.fetch_one() for _ in range(limit) if self.read()]\n        return list(self.fetch_stream())\n\n    def fetch_stream(self) -&gt; Iterator[dict[str, Any]]:\n        \"\"\"Fetches the rows from the last executed query as a stream of dictionaries.\n\n        Note:\n        ----\n            You may need to close the reader after fetching the rows if:\n\n            1. You are using a explicit limit that is shorter than the total number of\n            rows in the query result\n            2. You are tracing the command associated with the reader\n\n            This is because the trace will not create a query end record (since it\n            assumes the client is still reading) without explicitly closing the\n            reader. The reader can be closed with `self._reader.Close()`\n\n        \"\"\"\n        column_names = self.column_names()\n        while self.read():\n            yield dict(zip(column_names, self.fetch_one_tuple(), strict=False))\n\n    @property\n    def field_count(self) -&gt; int:\n        return self._reader.FieldCount\n\n    @property\n    def is_closed(self) -&gt; bool:\n        return self._reader.IsClosed\n\n    def read(self) -&gt; bool:\n        try:\n            return self._reader.Read()\n        except AdomdUnknownResponseException:\n            return False\n\n    def read_outer_xml(self) -&gt; str:\n        return self._reader.ReadOuterXml()\n</code></pre>"},{"location":"api/Reader/#pbi_pyadomd.Reader.column_names","title":"column_names","text":"<pre><code>column_names() -&gt; list[str]\n</code></pre> <p>Returns the column names of the last executed query.</p> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\reader.py</code> <pre><code>def column_names(self) -&gt; list[str]:\n    \"\"\"Returns the column names of the last executed query.\"\"\"\n    return [self._reader.GetName(i) for i in range(self.field_count)]\n</code></pre>"},{"location":"api/Reader/#pbi_pyadomd.Reader.fetch_many","title":"fetch_many","text":"<pre><code>fetch_many(\n    limit: int | None = None,\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Fetches multiple rows from the last executed query.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>The number of rows to fetch. If None, fetches all rows.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: A list of dictionaries representing the rows.</p> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\reader.py</code> <pre><code>def fetch_many(self, limit: int | None = None) -&gt; list[dict[str, Any]]:\n    \"\"\"Fetches multiple rows from the last executed query.\n\n    Args:\n        limit (int | None): The number of rows to fetch. If None, fetches all rows.\n\n    Returns:\n        list[dict[str, Any]]: A list of dictionaries representing the rows.\n\n    \"\"\"\n    if limit is not None:\n        return [self.fetch_one() for _ in range(limit) if self.read()]\n    return list(self.fetch_stream())\n</code></pre>"},{"location":"api/Reader/#pbi_pyadomd.Reader.fetch_one","title":"fetch_one","text":"<pre><code>fetch_one() -&gt; dict[str, Any]\n</code></pre> <p>Fetches a single row from the last executed query as a dictionary.</p>"},{"location":"api/Reader/#pbi_pyadomd.Reader.fetch_one--returns","title":"Returns","text":"<pre><code>dict[str, Any]: A dictionary representing the row, with column names as keys\n</code></pre> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\reader.py</code> <pre><code>def fetch_one(self) -&gt; dict[str, Any]:\n    \"\"\"Fetches a single row from the last executed query as a dictionary.\n\n    Returns\n    -------\n        dict[str, Any]: A dictionary representing the row, with column names as keys\n\n    \"\"\"\n    column_names = self.column_names()\n    data = self.fetch_one_tuple()\n    return dict(zip(column_names, data, strict=False))\n</code></pre>"},{"location":"api/Reader/#pbi_pyadomd.Reader.fetch_one_tuple","title":"fetch_one_tuple","text":"<pre><code>fetch_one_tuple() -&gt; tuple[Any, ...]\n</code></pre> <p>Fetches a single row from the last executed query as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>tuple[Any, ...]: A tuple representing the row, with C# values converted to their appropriate python types.</p> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\reader.py</code> <pre><code>def fetch_one_tuple(self) -&gt; tuple[Any, ...]:\n    \"\"\"Fetches a single row from the last executed query as a tuple.\n\n    Returns:\n        tuple[Any, ...]: A tuple representing the row, with C# values converted\n            to their appropriate python types.\n\n    \"\"\"\n    return tuple(\n        convert(\n            self._reader.GetFieldType(i).ToString(),\n            self._reader[i],\n            adomd_type_map,\n        )\n        for i in range(self.field_count)\n    )\n</code></pre>"},{"location":"api/Reader/#pbi_pyadomd.Reader.fetch_stream","title":"fetch_stream","text":"<pre><code>fetch_stream() -&gt; Iterator[dict[str, Any]]\n</code></pre> <p>Fetches the rows from the last executed query as a stream of dictionaries.</p>"},{"location":"api/Reader/#pbi_pyadomd.Reader.fetch_stream--note","title":"Note:","text":"<pre><code>You may need to close the reader after fetching the rows if:\n\n1. You are using a explicit limit that is shorter than the total number of\nrows in the query result\n2. You are tracing the command associated with the reader\n\nThis is because the trace will not create a query end record (since it\nassumes the client is still reading) without explicitly closing the\nreader. The reader can be closed with `self._reader.Close()`\n</code></pre> Source code in <code>venv\\Lib\\site-packages\\pbi_pyadomd\\reader.py</code> <pre><code>def fetch_stream(self) -&gt; Iterator[dict[str, Any]]:\n    \"\"\"Fetches the rows from the last executed query as a stream of dictionaries.\n\n    Note:\n    ----\n        You may need to close the reader after fetching the rows if:\n\n        1. You are using a explicit limit that is shorter than the total number of\n        rows in the query result\n        2. You are tracing the command associated with the reader\n\n        This is because the trace will not create a query end record (since it\n        assumes the client is still reading) without explicitly closing the\n        reader. The reader can be closed with `self._reader.Close()`\n\n    \"\"\"\n    column_names = self.column_names()\n    while self.read():\n        yield dict(zip(column_names, self.fetch_one_tuple(), strict=False))\n</code></pre>"}]}